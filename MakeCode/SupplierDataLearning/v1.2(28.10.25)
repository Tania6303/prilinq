// Supplier Data Learning - גרסה 1.2
// תאריך: 28 אוקטובר 2025
// עדכונים: מבנה JSON חדש, לוגיקה משופרת, תמיכה ברכבים, DEBIT כתבנית נפרדת

// ============================================================================
// פונקציות עזר - המרת תאריכים
// ============================================================================

function convertDateToFormat(dateStr) {
    if (!dateStr) return '';
    
    // אם כבר בפורמט DD/MM/YY
    if (typeof dateStr === 'string' && dateStr.match(/^\d{2}\/\d{2}\/\d{2}$/)) {
        return dateStr;
    }
    
    // אם ISO format
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) return dateStr;
    
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = String(date.getFullYear()).slice(-2);
    
    return `${day}/${month}/${year}`;
}

// ============================================================================
// פונקציה לזיהוי סוג מסמך + DEBIT
// ============================================================================

function identifyDocumentType(invoice) {
    const hasImport = !!invoice.IMPFNUM;
    const debitType = invoice.DEBIT || 'D';
    
    const accnames = new Set();
    let hasDateRange = false;
    let hasBudcode = false;
    let hasPdaccname = false;
    
    if (invoice.PINVOICEITEMS || invoice.PINVOICEITEMS_SUBFORM) {
        const items = invoice.PINVOICEITEMS || invoice.PINVOICEITEMS_SUBFORM;
        items.forEach(item => {
            if (item.ACCNAME) accnames.add(item.ACCNAME);
            if (item.FROMDATE || item.TODATE) hasDateRange = true;
            if (item.BUDCODE) hasBudcode = true;
            if (item.PDACCNAME) hasPdaccname = true;
        });
    }
    
    const hasDoc = !!((invoice.PIVDOC && invoice.PIVDOC.length > 0) || 
                      (invoice.PIVDOC_SUBFORM && invoice.PIVDOC_SUBFORM.length > 0) ||
                      invoice.DOCNO);
    
    const accnamesSorted = Array.from(accnames).sort().join(',');
    
    return {
        type_key: `${hasImport ? 'IMP' : 'REG'}_${debitType}_ACC_${accnamesSorted}_DR_${hasDateRange}_BUD_${hasBudcode}_PD_${hasPdaccname}_DOC_${hasDoc}`,
        has_import: hasImport,
        debit_type: debitType,
        accnames: Array.from(accnames),
        has_date_range: hasDateRange,
        has_budcode: hasBudcode,
        has_pdaccname: hasPdaccname,
        has_doc: hasDoc
    };
}

// ============================================================================
// ניתוח inventory_management
// ============================================================================

function analyzeInventoryManagement(invoices) {
    const prsourcenames = new Set();
    
    invoices.forEach(invoice => {
        const items = invoice.PINVOICEITEMS || invoice.PINVOICEITEMS_SUBFORM;
        if (items && items.length > 0 && items[0].PRSOURCENAME) {
            prsourcenames.add(items[0].PRSOURCENAME);
        }
    });
    
    // אם כל החשבוניות עם אותו PRSOURCENAME
    if (prsourcenames.size === 1) {
        const value = Array.from(prsourcenames)[0];
        if (value === 'קבלה למלאי') return 'managed_inventory';
        if (value === 'ידני') return 'not_managed_inventory';
    }
    
    return 'not_managed_inventory'; // ברירת מחדל
}

// ============================================================================
// חילוץ מידע ספק (vendor_tax_id, phone, email)
// ============================================================================

function extractSupplierInfo(invoices) {
    const info = {
        vendor_tax_id_reference: '',
        supplier_phone: '',
        supplier_email: ''
    };
    
    for (const invoice of invoices) {
        const cont = invoice.PINVOICESCONT || invoice.PINVOICESCONT_SUBFORM;
        if (cont && cont.length > 0) {
            if (!info.vendor_tax_id_reference && cont[0].IVREF) {
                info.vendor_tax_id_reference = cont[0].IVREF;
            }
            if (!info.supplier_phone && cont[0].PHONE) {
                info.supplier_phone = cont[0].PHONE;
            }
            if (!info.supplier_email && cont[0].EMAIL) {
                info.supplier_email = cont[0].EMAIL;
            }
        }
        
        if (info.vendor_tax_id_reference && info.supplier_phone && info.supplier_email) {
            break;
        }
    }
    
    return info;
}

// ============================================================================
// ניתוח חוקי רכבים
// ============================================================================

function analyzeVehicleRules(invoices) {
    const vehicleData = {};
    
    invoices.forEach(invoice => {
        const items = invoice.PINVOICEITEMS || invoice.PINVOICEITEMS_SUBFORM;
        if (!items) return;
        
        items.forEach(item => {
            if (item.PARTNAME !== 'car') return;
            
            // חילוץ מספר רכב מ-ACCDES
            const accdes = item.ACCDES || '';
            const vehicleMatch = accdes.match(/^(\d{3}-\d{2}-\d{3})/);
            
            if (vehicleMatch && item.ACCNAME) {
                const vehicleNumber = vehicleMatch[1];
                
                if (!vehicleData[vehicleNumber]) {
                    vehicleData[vehicleNumber] = {
                        accname: item.ACCNAME,
                        accdes: accdes,
                        vatflag_values: new Set(),
                        specialvatflag_values: new Set(),
                        has_fromdate: new Set(),
                        has_todate: new Set(),
                        has_pdaccname: new Set()
                    };
                }
                
                const vd = vehicleData[vehicleNumber];
                if (item.VATFLAG) vd.vatflag_values.add(item.VATFLAG);
                if (item.SPECIALVATFLAG) vd.specialvatflag_values.add(item.SPECIALVATFLAG);
                vd.has_fromdate.add(!!item.FROMDATE);
                vd.has_todate.add(!!item.TODATE);
                vd.has_pdaccname.add(!!item.PDACCNAME);
            }
        });
    });
    
    // המרה לפורמט סופי
    const vehicleRules = {};
    Object.keys(vehicleData).forEach(vehicleNumber => {
        const vd = vehicleData[vehicleNumber];
        
        vehicleRules[vehicleNumber] = {
            accname: vd.accname,
            accdes: vd.accdes,
            vat_pattern: {
                VATFLAG: vd.vatflag_values.size === 1 ? Array.from(vd.vatflag_values)[0] : 'varies',
                SPECIALVATFLAG: vd.specialvatflag_values.size === 1 ? Array.from(vd.specialvatflag_values)[0] : 'varies'
            },
            date_range_pattern: vd.has_fromdate.has(true) ? 'sometimes' : 'never',
            pdaccname_pattern: vd.has_pdaccname.has(true) ? 'sometimes' : 'never'
        };
    });
    
    return vehicleRules;
}

// ============================================================================
// ניתוח עמוק של ספק
// ============================================================================

function deepAnalyzeSupplier(invoices) {
    const analysis = {
        supplier_name: '',
        supplier_info: {},
        all_data: invoices,
        partnames: {},
        vehicle_rules: {},
        has_doc: false,
        has_pivordi: false,
        has_delivery_notes: false,
        has_docno: false,
        has_ordname: false,
        has_sdinumit: false,
        has_impfnum: false,
        inventory_management: 'not_managed_inventory',
        document_types: [],
        totquant_sample: 0
    };
    
    const docTypesSeen = new Map();
    
    // שם ספק ומידע
    if (invoices.length > 0 && invoices[0].SUPDES) {
        analysis.supplier_name = invoices[0].SUPDES;
    }
    
    analysis.supplier_info = extractSupplierInfo(invoices);
    analysis.inventory_management = analyzeInventoryManagement(invoices);
    
    // ניתוח כל החשבוניות
    invoices.forEach(data => {
        const docType = identifyDocumentType(data);
        if (!docTypesSeen.has(docType.type_key)) {
            docTypesSeen.set(docType.type_key, {
                ...docType,
                sample: data
            });
        }
        
        // זיהוי שדות מיוחדים
        if ((data.PIVDOC && data.PIVDOC.length > 0) || 
            (data.PIVDOC_SUBFORM && data.PIVDOC_SUBFORM.length > 0) ||
            data.DOCNO) {
            analysis.has_doc = true;
        }
        if (data.PIVORDI && data.PIVORDI.length > 0) analysis.has_pivordi = true;
        if (data.SDINUMIT) analysis.has_sdinumit = true;
        if (data.DOCNO) analysis.has_docno = true;
        if (data.ORDNAME) analysis.has_ordname = true;
        if (data.IMPFNUM) analysis.has_impfnum = true;
        
        // TOTQUANT לדוגמה
        if (data.TOTQUANT && !analysis.totquant_sample) {
            analysis.totquant_sample = data.TOTQUANT;
        }
    });
    
    analysis.has_delivery_notes = analysis.has_sdinumit || analysis.has_docno;
    
    // ניתוח מקטים (רק אם אין תעודות)
    const needsPartnameAnalysis = !analysis.has_doc && !analysis.has_delivery_notes;
    
    if (needsPartnameAnalysis) {
        invoices.forEach(data => {
            const items = data.PINVOICEITEMS || data.PINVOICEITEMS_SUBFORM;
            if (items) {
                items.forEach(item => {
                    const partname = item.PARTNAME || '';
                    if (partname && partname !== 'car') {
                        if (!analysis.partnames[partname]) {
                            analysis.partnames[partname] = {
                                accnames: new Set(),
                                has_pdaccname: false,
                                sample_pdes: new Set()
                            };
                        }
                        
                        if (item.ACCNAME) {
                            analysis.partnames[partname].accnames.add(item.ACCNAME);
                        }
                        if (item.PDACCNAME) {
                            analysis.partnames[partname].has_pdaccname = true;
                        }
                        if (item.PDES) {
                            analysis.partnames[partname].sample_pdes.add(item.PDES.substring(0, 50));
                        }
                    }
                });
            }
        });
    }
    
    // ניתוח רכבים
    analysis.vehicle_rules = analyzeVehicleRules(invoices);
    
    analysis.document_types = Array.from(docTypesSeen.values());
    
    return analysis;
}

// ============================================================================
// בדיקה אם תבניות צריכות להתמזג (רק הבדל במקטים/חשבונות)
// ============================================================================

function shouldMergeTemplates(type1, type2) {
    const fieldsToCompare = ['has_import', 'debit_type', 'has_date_range', 'has_budcode', 'has_pdaccname', 'has_doc'];
    
    for (const field of fieldsToCompare) {
        if (type1[field] !== type2[field]) {
            return false;
        }
    }
    
    return true;
}

// ============================================================================
// מיזוג תבניות זהות (שההבדל רק במקטים)
// ============================================================================

function mergeIdenticalTemplates(documentTypes) {
    if (documentTypes.length <= 1) {
        return documentTypes;
    }
    
    const merged = [];
    const processed = new Set();
    
    for (let i = 0; i < documentTypes.length; i++) {
        if (processed.has(i)) continue;
        
        let currentType = { ...documentTypes[i] };
        const allAccnames = new Set(currentType.accnames || []);
        let allSamples = [currentType.sample];
        
        for (let j = i + 1; j < documentTypes.length; j++) {
            if (processed.has(j)) continue;
            
            if (shouldMergeTemplates(currentType, documentTypes[j])) {
                // מיזוג accnames
                (documentTypes[j].accnames || []).forEach(acc => allAccnames.add(acc));
                allSamples.push(documentTypes[j].sample);
                processed.add(j);
            }
        }
        
        currentType.accnames = Array.from(allAccnames);
        currentType.all_samples = allSamples;
        
        merged.push(currentType);
        processed.add(i);
    }
    
    return merged;
}

// ============================================================================
// חישוב type (סוג מסמך) לפי מבנה
// ============================================================================

function calculateDocumentType(docType) {
    if (docType.debit_type === 'C') {
        if (docType.has_import) {
            return 'זיכוי יבוא';
        }
        if (docType.has_doc) {
            return 'זיכוי עם תעודות ללא פירוט';
        }
        return 'זיכוי רגיל עם פירוט';
    }
    
    if (docType.has_import) {
        if (docType.has_doc) {
            return 'חשבונית עם תיק יבוא עם תעודות';
        }
        return 'חשבונית עם תיק יבוא - הוצאות ללא תעודות';
    }
    
    if (docType.has_doc) {
        return 'חשבונית עם תעודות ללא פירוט';
    }
    
    return 'חשבונית רגילה עם פירוט';
}

// ============================================================================
// יצירת config מתקדם
// ============================================================================

function createAdvancedConfig(supplierId, analysis) {
    const config = {
        supplier_config: {
            supplier_code: supplierId,
            supplier_name: analysis.supplier_name,
            vendor_tax_id_reference: analysis.supplier_info.vendor_tax_id_reference
        },
        structure: [],
        rules: {
            invoice_date_format: 'DD/MM/YY',
            doc_variation: analysis.has_doc ? 'תעודה אחת (DOCNO) או מרובות (PIVDOC_SUBFORM) - שניהם בתבנית' : '',
            validation_data: {
                TOTQUANT: analysis.totquant_sample
            },
            critical_patterns: {
                vehicle_rules: Object.keys(analysis.vehicle_rules).length > 0 ? {
                    partname: 'car',
                    vehicle_account_mapping: analysis.vehicle_rules
                } : {},
                partname_rules: {}
            }
        },
        document_types: []
    };
    
    // מיזוג תבניות
    const mergedTypes = mergeIdenticalTemplates(analysis.document_types);
    
    // יצירת structure ו-document_types
    mergedTypes.forEach(docType => {
        // has_purchase_orders לפי הכלל החדש (סעיף 1)
        let hasPurchaseOrders = false;
        if (docType.has_import) {
            hasPurchaseOrders = true; // יבוא - תמיד
        } else if (!docType.has_doc && !analysis.has_delivery_notes && analysis.has_ordname) {
            hasPurchaseOrders = true; // אין תעודות אבל יש הזמנה
        }
        
        const structureItem = {
            has_import: docType.has_import,
            has_purchase_orders: hasPurchaseOrders,
            has_doc: docType.has_doc,
            has_date_range: docType.has_date_range,
            has_budcode: docType.has_budcode,
            has_pdaccname: docType.has_pdaccname,
            inventory_management: analysis.inventory_management,
            debit_type: docType.debit_type
        };
        
        config.structure.push(structureItem);
        
        const documentTypeItem = {
            type: calculateDocumentType(docType),
            accnames: docType.accnames
        };
        
        config.document_types.push(documentTypeItem);
    });
    
    // הוספת partname_rules (רק אם אין תעודות ויש מקטים)
    if (!analysis.has_doc && !analysis.has_delivery_notes && Object.keys(analysis.partnames).length > 0) {
        const partnameRules = {};
        
        Object.keys(analysis.partnames).forEach(partname => {
            const info = analysis.partnames[partname];
            partnameRules[partname] = {
                accnames: Array.from(info.accnames),
                has_pdaccname: info.has_pdaccname,
                sample_description: Array.from(info.sample_pdes)[0] || ''
            };
        });
        
        config.rules.critical_patterns.partname_rules = partnameRules;
    }
    
    return config;
}

// ============================================================================
// ניקוי תבנית - רק שדות רלוונטיים
// ============================================================================

function cleanTemplate(sample, analysis, docType) {
    const cleaned = {
        SUPNAME: sample.SUPNAME,
        CODE: sample.CODE,
        DEBIT: sample.DEBIT,
        IVDATE: convertDateToFormat(sample.IVDATE),
        BOOKNUM: sample.BOOKNUM
    };
    
    // DOCNO אם יש תעודה אחת
    if (sample.DOCNO) {
        cleaned.DOCNO = sample.DOCNO;
    }
    
    // ORDNAME רק אם צריך הזמנה
    if (docType.has_import || (!docType.has_doc && !analysis.has_delivery_notes && analysis.has_ordname)) {
        if (sample.ORDNAME) {
            cleaned.ORDNAME = sample.ORDNAME;
        }
    }
    
    // IMPFNUM אם יבוא
    if (docType.has_import && sample.IMPFNUM) {
        cleaned.IMPFNUM = sample.IMPFNUM;
    }
    
    // SDINUMIT אם יש
    if (sample.SDINUMIT) {
        cleaned.SDINUMIT = sample.SDINUMIT;
    }
    
    // DETAILS אם יש
    if (sample.DETAILS) {
        cleaned.DETAILS = sample.DETAILS;
    }
    
    // PIVDOC_SUBFORM אם יש תעודות מרובות
    if (docType.has_doc) {
        cleaned.PIVDOC_SUBFORM = [
            {
                DOCNO: '',
                BOOKNUM: ''
            }
        ];
    }
    
    // PINVOICEITEMS_SUBFORM אם אין תעודות
    if (!docType.has_doc && !analysis.has_delivery_notes) {
        const items = sample.PINVOICEITEMS || sample.PINVOICEITEMS_SUBFORM;
        if (items && items.length > 0) {
            cleaned.PINVOICEITEMS_SUBFORM = items.map(item => {
                const cleanedItem = {
                    PARTNAME: item.PARTNAME,
                    PDES: item.PDES,
                    TQUANT: item.TQUANT,
                    TUNITNAME: item.TUNITNAME,
                    PRICE: item.PRICE,
                    VATFLAG: item.VATFLAG,
                    ACCNAME: item.ACCNAME
                };
                
                // ICODE רק אם שונה מכותרת
                if (item.ICODE && item.ICODE !== sample.CODE) {
                    cleanedItem.ICODE = item.ICODE;
                }
                
                if (item.SPECIALVATFLAG) cleanedItem.SPECIALVATFLAG = item.SPECIALVATFLAG;
                if (item.BUDCODE) cleanedItem.BUDCODE = item.BUDCODE;
                if (item.FROMDATE) cleanedItem.FROMDATE = item.FROMDATE;
                if (item.TODATE) cleanedItem.TODATE = item.TODATE;
                if (item.PDACCNAME) cleanedItem.PDACCNAME = item.PDACCNAME;
                
                return cleanedItem;
            });
        }
    }
    
    // PINVOICESCONT_SUBFORM - רק אם יש שדות רלוונטיים
    const cont = sample.PINVOICESCONT || sample.PINVOICESCONT_SUBFORM;
    if (cont && cont.length > 0) {
        const fncpatname = cont[0].FNCPATNAME;
        // רק אם FNCPATNAME שונה מ"חסמ"
        if (fncpatname && fncpatname !== 'חסמ') {
            cleaned.PINVOICESCONT_SUBFORM = [{
                FNCPATNAME: fncpatname
            }];
        }
    }
    
    return cleaned;
}

// ============================================================================
// יצירת תבנית מרובה
// ============================================================================

function createMultiSampleTemplate(analysis) {
    const mergedTypes = mergeIdenticalTemplates(analysis.document_types);
    const samples = [];
    
    mergedTypes.forEach(docType => {
        // אם יש מיזוג תבניות (פירוט) - לקחת כל הרשומות השונות
        if (docType.all_samples && docType.all_samples.length > 1 && !docType.has_doc) {
            // מיזוג כל הפריטים מכל הדוגמאות
            const allItems = [];
            const seenItems = new Set();
            
            docType.all_samples.forEach(sample => {
                const items = sample.PINVOICEITEMS || sample.PINVOICEITEMS_SUBFORM;
                if (items) {
                    items.forEach(item => {
                        const itemKey = `${item.PARTNAME}_${item.ACCNAME}`;
                        if (!seenItems.has(itemKey)) {
                            allItems.push(item);
                            seenItems.add(itemKey);
                        }
                    });
                }
            });
            
            // יצירת תבנית אחת עם כל הפריטים
            const baseSample = docType.all_samples[0];
            const cleanedSample = cleanTemplate(baseSample, analysis, docType);
            
            if (allItems.length > 0) {
                cleanedSample.PINVOICEITEMS_SUBFORM = allItems.map(item => {
                    const cleanedItem = {
                        PARTNAME: item.PARTNAME,
                        PDES: item.PDES,
                        TQUANT: item.TQUANT,
                        TUNITNAME: item.TUNITNAME,
                        PRICE: item.PRICE,
                        VATFLAG: item.VATFLAG,
                        ACCNAME: item.ACCNAME
                    };
                    
                    if (item.ICODE && item.ICODE !== baseSample.CODE) {
                        cleanedItem.ICODE = item.ICODE;
                    }
                    if (item.SPECIALVATFLAG) cleanedItem.SPECIALVATFLAG = item.SPECIALVATFLAG;
                    if (item.BUDCODE) cleanedItem.BUDCODE = item.BUDCODE;
                    if (item.FROMDATE) cleanedItem.FROMDATE = item.FROMDATE;
                    if (item.TODATE) cleanedItem.TODATE = item.TODATE;
                    if (item.PDACCNAME) cleanedItem.PDACCNAME = item.PDACCNAME;
                    
                    return cleanedItem;
                });
            }
            
            samples.push(cleanedSample);
        } else {
            // תבנית רגילה
            const sample = docType.sample;
            samples.push(cleanTemplate(sample, analysis, docType));
        }
    });
    
    return {
        PINVOICES: samples,
        document_types_count: samples.length
    };
}

// ============================================================================
// יצירת דוגמאות מומלצות (אקראיות)
// ============================================================================

function createRecommendedSamples(analysis) {
    const mergedTypes = mergeIdenticalTemplates(analysis.document_types);
    const samples = [];
    
    mergedTypes.forEach(() => {
        // בחירה אקראית מתוך כל החשבוניות
        const randomIndex = Math.floor(Math.random() * analysis.all_data.length);
        const randomInvoice = analysis.all_data[randomIndex];
        
        samples.push({
            sample_ivnum: randomInvoice.IVNUM || '',
            sample_booknum: randomInvoice.BOOKNUM || '',
            sample_impfnum: randomInvoice.IMPFNUM || '',
            sample_supname: randomInvoice.SUPNAME || ''
        });
    });
    
    return {
        samples: samples
    };
}

// ============================================================================
// הפונקציה הראשית
// ============================================================================

function processSupplierInvoices(invoicesJson, supplierId) {
    try {
        let invoices = invoicesJson;
        if (typeof invoicesJson === 'string') {
            invoices = JSON.parse(invoicesJson);
        }
        
        if (!Array.isArray(invoices)) {
            throw new Error('invoices_json must be an array');
        }
        
        const analysis = deepAnalyzeSupplier(invoices);
        const config = createAdvancedConfig(supplierId, analysis);
        const template = createMultiSampleTemplate(analysis);
        const recommended = createRecommendedSamples(analysis);
        
        return {
            status: 'success',
            supplier_id: supplierId,
            supplier_name: analysis.supplier_name,
            vendor_tax_id_reference: analysis.supplier_info.vendor_tax_id_reference,
            supplier_phone: analysis.supplier_info.supplier_phone,
            supplier_email: analysis.supplier_info.supplier_email,
            json_files_analyzed: invoices.length,
            templates_detected: template.document_types_count,
            config: config,
            template: template,
            recommended_samples: recommended
        };
        
    } catch (error) {
        return {
            status: 'error',
            message: error.message,
            stack: error.stack
        };
    }
}

// ============================================================================
// קוד הרצה למייק
// ============================================================================

const supplierId = input.supplier_id;

let invoices;
try {
    let rawData = input.invoices_json;
    
    if (rawData && typeof rawData === 'object' && rawData.type === 'Buffer' && Array.isArray(rawData.data)) {
        const uint8Array = new Uint8Array(rawData.data);
        const decoder = new TextDecoder('utf-8');
        const text = decoder.decode(uint8Array);
        invoices = JSON.parse(text);
    }
    else if (typeof rawData === 'string') {
        invoices = JSON.parse(rawData);
    }
    else {
        invoices = rawData;
    }
    
    if (!Array.isArray(invoices)) {
        return {
            status: 'error',
            message: 'invoices_json must be an array after parsing. Received: ' + typeof invoices,
            received_structure: JSON.stringify(invoices).substring(0, 300)
        };
    }
    
} catch (e) {
    return {
        status: 'error',
        message: 'Failed to parse invoices_json: ' + e.message,
        error_stack: e.stack,
        received_type: typeof input.invoices_json
    };
}

const result = processSupplierInvoices(invoices, supplierId);

return result;
